# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⣴⣤⣤⣤⣤⣤⡄⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⠟⢋⣵⣿⣿⣿⡿⠛⣩⣤⣿⣿⣿⣿⣿⣿⣿⣬⣙⠻⣿⣿⣿⣷⡍⠛⢿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⠟⢹⠃⣠⣾⣿⣿⡿⢋⣴⣿⣿⣿⣿⠿⠿⠈⠿⢿⣿⣿⣿⣷⣤⡙⣿⣿⣿⢦⡀⢣⠙⣿⣿⣿⣿
# ⣿⣿⡿⡿⠀⡯⠊⣡⣿⣿⠏⣴⣿⣿⣿⠟⠁⣀⣤⣤⠀⣤⣤⡀⠙⠻⣿⣿⣿⣌⢻⣿⣧⡉⠺⡄⢸⠹⣿⣿
# ⣿⣿⠃⢷⠀⡠⢺⣿⣿⡏⣰⣿⣿⡟⠁⣠⣾⣿⣿⠿⠀⠿⣿⣿⣷⡄⠘⣿⣿⣿⡄⣿⣿⣯⠢⡀⢸⠀⢹⣿
# ⣿⣿⠀⢸⠊⣠⣿⣿⣿⢀⣿⣿⣿⠁⣰⣿⣿⣿⣿⣆⢀⣼⣿⣿⣿⣿⡄⢸⣿⣿⣿⣹⣿⣿⣦⠈⢺⠀⢸⣿
# ⣿⠹⡆⠀⣴⢻⣿⣿⣿⢸⣿⣿⣿⠀⣿⣿⡿⠿⠿⢿⣿⠿⠿⠿⣿⣿⡇⢈⣿⣿⣿⠀⣿⣿⣿⠳⡀⢀⡇⢸
# ⣿⡀⠹⣸⠉⣿⣿⡿⢋⣠⣿⣿⣿⡀⠸⠟⢋⣀⢠⣾⣿⣷⡀⣀⡙⠻⠁⢸⣿⣿⣿⣈⠻⣿⣿⡄⠹⡜⠀⣸
# ⣿⢧⠀⠇⢠⣿⣿⣷⡘⣿⣿⣿⣟⣁⡀⠘⢿⣿⣿⣿⣿⣿⣿⣿⠿⠀⣠⣉⣿⣿⣿⡿⢠⣿⡿⢧⠀⠁⣰⢿
# ⣿⡌⢷⡄⣾⠀⣿⣿⣷⡜⢿⣿⣿⣿⣿⣦⣄⠈⠉⠛⠛⠛⠉⢁⣠⣾⣿⣿⣿⣿⡟⣰⣿⣿⡇⢸⢀⡴⠃⣼
# ⣿⣷⣄⠙⢿⠀⣿⢿⣿⣿⣌⠿⠟⡻⣿⣿⣿⣿⣷⣶⣶⣶⣿⣿⣿⣿⡿⠛⠿⠟⣼⣿⡿⢫⠃⢸⠋⢀⣼⣿
# ⣿⣿⣟⣶⣄⡀⢸⡀⢻⣿⣿⣾⣿⣿⣶⣍⣙⠛⠿⠿⠿⠿⠿⠛⣋⣥⣶⣿⣿⣾⣿⣿⠁⣸⢀⣴⣶⣯⣿⣿
# ⣿⣿⣿⣿⣿⣿⠾⣧⠀⢯⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⡿⢫⠃⢠⢷⣛⣉⣽⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣄⣁⡈⢧⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⢋⣀⣠⣴⣾⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣯⣉⠉⠉⠉⣀⣀⡭⠟⠛⢛⣛⠛⠛⠛⣛⠛⠛⠩⣥⣀⣈⢁⢀⣀⣴⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣝⡛⢉⣁⣀⣤⠖⣫⣴⣿⣿⣷⣬⡙⣦⣤⣀⡈⣉⣩⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣼⣿⣿⣿⣿⣿⣿⣿⣧⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
#
#    _____ __________     ____        __        __
#   / ___// ____/ __ \   / __ \____ _/ /_____ _/ /_  ____ _________
#   \__ \/ /   / /_/ /  / / / / __ `/ __/ __ `/ __ \/ __ `/ ___/ _ \
#  ___/ / /___/ ____/  / /_/ / /_/ / /_/ /_/ / /_/ / /_/ (__  )  __/
# /____/\____/_/      /_____/\__,_/\__/\__,_/_.___/\__,_/____/\___/
#
#               Created by Darrel (CatRass#5748)
#
#               Original Creation Date: 29/11/22
#                   Last Edited: 12/01/23

import sys
from PyQt6.QtCore import QSize, Qt
from PyQt6 import sip
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QPalette, QColor, QIcon, QFont, QFontDatabase, QImage, QPixmap

import requests
import urllib.request
from bs4 import BeautifulSoup

import inspect

def SCPScraper(scp):

        #   This function is responsible for scraping the SCP Wiki and collecting all the relevant information for displaying it on the database GUI. Currently it collects:
        #       - Headings  (<strong></strong>)
        #       - Paragaphs/Text (<p></p>)
        #       - Image Captions
        #   This is accomplished through grabbing a specific pages source code using Requests, and breaking the scraped code with BeautifulSoup

    url = 'https://scp-wiki.wikidot.com/scp-{}'.format(scp)
    htmlSource = requests.get(url)  #   The sites HTML is scraped
    soup = BeautifulSoup(htmlSource.text, 'html.parser')    #   htmlSource is transformed into a bs4 object for analysis
    pageContents = soup.find("div", { "id" : "page-content" })  #   The webpage is redyuced to everything within div "page-content"
                                                                #   ↑ Refer to Folio (Analysis → Research → SCP Wiki Article Structure)
    relevantPageContents = pageContents.find_all("p")    #   Find all contents with the <p></p> tag

    allContents = {}
    currentKey = "None" #   In case text doesnt have a heading, the previous one will be used

    removableText = [
    "« SCP-{previous} | SCP-{current} | SCP-{next} »".format(previous="00"+str(int(scp)-1),current="00"+str(int(scp)),next="00"+str(int(scp)+1))]
    # print(removableText)

    def textRemover(currentEntry):
        for i in removableText:
            # print(i)
            if i == currentEntry:
                currentEntry = "Cring"

    for i in range(0,len(relevantPageContents)):

        # TODO: Fix issues with similar non-none <strong></strong> headings being put into one variable such as the case for SCP-163


        try:    #   Not every piece of text will have a heading, hence a try except statement in case it does not.
            currentTitle = relevantPageContents[i].find('strong')   #   If a heading is found add to variable
        except:
            currentTitle = None #   If a heading not found, make None

        currentText = relevantPageContents[i]   #   Set text to the current item

        if currentTitle != None:
            for strong in currentText.find_all('strong'): strong.extract()
            for pTags in currentText.find_all("p"):    #   Find all contents with the <p></p> tag
                currentText = currentText.get_text() #   Remove <p></p> tags

            # textRemover(currentText.text)
            # print(currentText)

            allContents[currentTitle.text]=currentText.text #   Append text into dictionary
            currentKey = currentTitle.text  #   Set the previous key in case next item has no heading
        else:
            try:    #   In case this is the first item without a heading, we use try/except
                # textRemover(currentText)
                # print(currentText)
                allContents[currentKey]+=(currentText.text+"\n\n")  #   Add to previous heading
            except:
                # textRemover(currentText)
                # print(currentText)
                allContents[currentKey]=currentText.text    #   If no previous heading, create new one with currrentKey

    try:
        imageContents = soup.find("div", { "class" : "scp-image-block block-right" })
        relevantImageContents = imageContents.find("img", { "class" : "image" })
        print(relevantImageContents["src"])
        allContents["Image"] = relevantImageContents["src"]
    except:
        allContents["Image"] = None

    print("SCP {} Scraped Info:".format(str(scp)),allContents)
    return allContents

class Color(QWidget):   #   Debug Widget that shows a coloured square
    def __init__(self, color):
        super(Color, self).__init__()
        self.setAutoFillBackground(True)
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(color))
        self.setPalette(palette)

class TestWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.toolSelector = toolSelector(["SCP's","Tales", "GOI's"])

class toolSelector(QComboBox):  #   Editable ComboBox
    def __init__(self,options):
        super(toolSelector,self).__init__()
        self.addItems(options)

class inputBar(QLineEdit):
    def __init__(self,placeHolderText,returnFunction):
        super(inputBar,self).__init__()
        self.setMaxLength(4)
        self.setPlaceholderText(placeHolderText)
        self.returnPressed.connect(returnFunction)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("SCP Database")
        self.setMinimumSize(QSize(400, 300))

        self.setWindowIcon(QIcon('icon.ico'))
        self.toolSelector = toolSelector(["SCP's","Tales"])
        self.scpInput = inputBar("Enter SCP Number",self.scpSearched)
        self.scpInput.setFont(QFont("VT323",15))

        self.button = QPushButton("Search", self)
        self.button.setFixedSize(120, 30)
        self.button.setFont(QFont("VT323",15))
        self.button.clicked.connect(self.scpSearched)

        self.scpSearchedBool = False

        self.layout = QGridLayout()
        self.layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        secondaryLayout = QVBoxLayout()
        self.layout.addWidget(self.scpInput, 0,0)
        self.layout.addWidget(self.button, 0,1)

        self.imageLabel = QLabel(self)
        self.layout.addWidget(self.imageLabel, 1,1)

        self.widget = QWidget()
        self.widget.setLayout(self.layout)
        self.setCentralWidget(self.widget)

    def scpSearched(self):

        scpInfo = SCPScraper(self.scpInput.text())  #   Store SCPScraper dictionary in a variable
                                                    #   ↑   scpInfo = {"Heading":"text","Heading2":"text"...}
        # self.scpInformation = QWidget() #   Widget to store all SCP Information
        self.scpInfoTextBrowser = QTextEdit(readOnly = False)
        self.scpInfoTextBrowser.clear()
        # self.scpInfoTextBrowser.setStyleSheet("color: grey; background-color: #333232")

        index = 1
        for key in scpInfo:
            self.scpInfoTextBrowser.setFont(QFont("VT323")) #   Sets the text font

            if key == "Image":
                if scpInfo[key] != None:    #   Check if the image exists

                    data = urllib.request.urlopen(scpInfo[key]).read()
                    image = QImage()
                    image.loadFromData(data)
                    imagePixMap = QPixmap(image)
                    imagePixMap= imagePixMap.scaled(256, 256, Qt.AspectRatioMode.KeepAspectRatio)   #   Resize the image keeping the aspect ratio

                    self.imageLabel.setPixmap(imagePixMap)
                    self.show()
                else:
                    self.imageLabel.clear() #   Clear the label if no image exists

            # ====  THIS IS A TEMPORARY SOLUTION TO REMOVING SOME UNFILTERED INFO   ====
            # TODO: Optimise this jazz
            elif key == "None":
                print("None Element:\n",scpInfo[key])
            elif key == "Filename:":
                print("Filename:\n",scpInfo[key])
            elif key == "Licensing Disclosures":
                print("Licensing Disclosures:\n",scpInfo[key])
            # ====  THIS IS A TEMPORARY SOLUTION TO REMOVING SOME UNFILTERED INFO   ====

            else:   #   If the entry in allContents is just regular text, put it in the TextBrowser
                self.scpInfoTextBrowser.setFontPointSize(20)
                self.scpInfoTextBrowser.setTextColor(QColor('Red'))
                self.scpInfoTextBrowser.setFontUnderline(True)
                self.scpInfoTextBrowser.append(key)

                self.scpInfoTextBrowser.setFontPointSize(15)
                self.scpInfoTextBrowser.setTextColor(QColor('white'))
                self.scpInfoTextBrowser.setFontUnderline(False)
                self.scpInfoTextBrowser.append(scpInfo[key])

                self.scpInfoTextBrowser.append('')

                index += 1

        self.layout.addWidget(self.scpInfoTextBrowser,1,0)

        self.scpInfoTextBrowser.setReadOnly(True)

        self.scpSearchedBool = True #   Indicate that the page has contents on it


app = QApplication(sys.argv)
window = MainWindow()
window.show()

QFontDatabase.addApplicationFont("/Styles/Fonts/VT323-Regular.ttf") #   Load the font from the .TTF file

stylesheet = open("Styles/stylesheet.css")  #   Load the Style Sheet from the .CSS file
style = stylesheet.read()

app.setStyleSheet(style)    #   Set the style


app.exec()
